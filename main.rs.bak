use std::collections::HashMap;
use std::env;
use std::fs::{self, File, OpenOptions};
use std::io::{self, BufRead, BufReader, Write};
use std::path::PathBuf;
use std::process::exit;
use chrono::{DateTime, Local};
use serde::{Deserialize, Serialize};
use rust_typecmd_plus::prelude;

// ========== 错误处理 ==========
type Result<T> = std::result::Result<T, TypeCmdError>;

// ========== 颜色定义 ==========
const RED: &str = "\x1b[31m";
const GREEN: &str = "\x1b[32m";
const YELLOW: &str = "\x1b[33m";
const BLUE: &str = "\x1b[34m";
const PURPLE: &str = "\x1b[35m";
const CYAN: &str = "\x1b[36m";
const GRAY: &str = "\x1b[90m";
const BOLD: &str = "\x1b[1m";
const RESET: &str = "\x1b[0m";

// ========== 数据结构 ==========
#[derive(Debug, Clone, Serialize, Deserialize)]
struct HistoryEntry {
    id: u64,
    command: String,
    timestamp: DateTime<Local>,
}

#[derive(Debug, Clone)]
struct VariableStore {
    store: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Config {
    max_history_size: usize,
    history_file: String,
    version: String,
}

// ========== 历史管理器 ==========
struct HistoryManager {
    entries: Vec<HistoryEntry>,
    next_id: u64,
    config: Config,
}

impl HistoryManager {
    fn new() -> Result<Self> {
        let config = Config {
            max_history_size: 1000,
            history_file: ".typecmd_history".to_string(),
            version: "0.4.0".to_string(),
        };
        
        let mut manager = HistoryManager {
            entries: Vec::new(),
            next_id: 1,
            config,
        };
        
        manager.load_history()?;
        Ok(manager)
    }
    
    fn history_path(&self) -> PathBuf {
        let home = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        PathBuf::from(home).join(&self.config.history_file)
    }
    
    fn load_history(&mut self) -> Result<()> {
        let path = self.history_path();
        
        if !path.exists() {
            return Ok(());
        }
        
        let file = File::open(&path)?;
        let reader = BufReader::new(file);
        
        for line in reader.lines() {
            let line = line?;
            if line.trim().is_empty() {
                continue;
            }
            
            let parts: Vec<&str> = line.splitn(3, '|').collect();
            if parts.len() == 3 {
                if let (Ok(id), Ok(timestamp)) = (
                    parts[0].parse::<u64>(),
                    parts[1].parse::<DateTime<Local>>()
                ) {
                    let entry = HistoryEntry {
                        id,
                        command: parts[2].to_string(),
                        timestamp,
                    };
                    
                    self.entries.push(entry);
                    self.next_id = self.next_id.max(id + 1);
                }
            }
        }
        
        // 限制历史记录大小
        if self.entries.len() > self.config.max_history_size {
            let excess = self.entries.len() - self.config.max_history_size;
            self.entries.drain(0..excess);
        }
        
        Ok(())
    }
    
    fn save_history(&self) -> Result<()> {
        let path = self.history_path();
        let mut file = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&path)?;
        
        for entry in &self.entries {
            writeln!(
                file,
                "{}|{}|{}",
                entry.id,
                entry.timestamp.to_rfc3339(),
                entry.command
            )?;
        }
        
        Ok(())
    }
    
    fn add(&mut self, command: &str) -> Result<()> {
        if command.trim().is_empty() {
            return Ok(());
        }
        
        // 跳过历史命令本身
        if command.starts_with("history") || command.starts_with('!') {
            return Ok(());
        }
        
        let entry = HistoryEntry {
            id: self.next_id,
            command: command.to_string(),
            timestamp: Local::now(),
        };
        
        self.entries.push(entry);
        self.next_id += 1;
        
        // 限制大小
        if self.entries.len() > self.config.max_history_size {
            self.entries.remove(0);
        }
        
        self.save_history()?;
        Ok(())
    }
    
    fn get(&self, limit: Option<usize>) -> Vec<HistoryEntry> {
        match limit {
            Some(l) => self.entries.iter().rev().take(l).cloned().collect(),
            None => self.entries.clone(),
        }
    }
    
    fn get_by_id(&self, id: u64) -> Option<&HistoryEntry> {
        self.entries.iter().find(|e| e.id == id)
    }
    
    fn search(&self, keyword: &str) -> Vec<&HistoryEntry> {
        let keyword_lower = keyword.to_lowercase();
        self.entries
            .iter()
            .filter(|e| e.command.to_lowercase().contains(&keyword_lower))
            .collect()
    }
    
    fn clear(&mut self) -> Result<()> {
        self.entries.clear();
        self.next_id = 1;
        let _ = fs::remove_file(self.history_path());
        Ok(())
    }
    
    fn last(&self) -> Option<&HistoryEntry> {
        self.entries.last()
    }
    
    fn count(&self) -> usize {
        self.entries.len()
    }
}

// ========== 变量管理器 ==========
impl VariableStore {
    fn new() -> Self {
        VariableStore {
            store: HashMap::new(),
        }
    }
    
    fn get(&self, key: &str) -> Option<&String> {
        self.store.get(key)
    }
    
    fn set(&mut self, key: String, value: String) {
        self.store.insert(key, value);
    }
    
    fn has(&self, key: &str) -> bool {
        self.store.contains_key(key)
    }
    
    fn delete(&mut self, key: &str) -> bool {
        self.store.remove(key).is_some()
    }
    
    fn clear(&mut self) {
        self.store.clear();
    }
    
    fn all(&self) -> &HashMap<String, String> {
        &self.store
    }
    
    fn len(&self) -> usize {
        self.store.len()
    }
}

// ========== 颜色输出 ==========
fn colorize(text: &str, color_code: &str) -> String {
    format!("{}{}{}", color_code, text, RESET)
}

fn print_error(msg: &str) {
    println!("{}错误: {}{}", RED, msg, RESET);
}

fn print_success(msg: &str) {
    println!("{}{}{}", GREEN, msg, RESET);
}

fn print_info(msg: &str) {
    println!("{}{}{}", BLUE, msg, RESET);
}

fn print_warn(msg: &str) {
    println!("{}警告: {}{}", YELLOW, msg, RESET);
}

fn print_gray(msg: &str) {
    println!("{}{}{}", GRAY, msg, RESET);
}

fn print_cyan(msg: &str) {
    println!("{}{}{}", CYAN, msg, RESET);
}

// ========== 命令解析 ==========
fn parse_command(input: &str) -> Result<Vec<String>> {
    let mut tokens = Vec::new();
    let mut current_token = String::new();
    let mut in_quotes = false;
    let mut in_single_quotes = false;
    let mut chars = input.chars().peekable();
    
    while let Some(c) = chars.next() {
        match c {
            '\\' => {
                if let Some(next_c) = chars.next() {
                    current_token.push(next_c);
                }
            }
            '"' if !in_single_quotes => {
                in_quotes = !in_quotes;
            }
            '\'' if !in_quotes => {
                in_single_quotes = !in_single_quotes;
            }
            ' ' if !in_quotes && !in_single_quotes => {
                if !current_token.is_empty() {
                    tokens.push(current_token.clone());
                    current_token.clear();
                }
            }
            _ => {
                current_token.push(c);
            }
        }
    }
    
    if !current_token.is_empty() {
        tokens.push(current_token);
    }
    
    if in_quotes || in_single_quotes {
        return Err(TypeCmdError::Parse("未闭合的引号".to_string()));
    }
    
    Ok(tokens)
}

// ========== 命令枚举 ==========
#[derive(Debug)]
enum Command {
    Show(ShowSubcommand),
    Exit(Option<i32>),
    Set(String, String),
    Get(String),
    StringCmd(String),
    IntCmd(Option<i32>),
    List,
    Delete(String),
    Clear(ClearTarget),
    History(HistorySubcommand),
    LastCommand,
    HistoryCommand(String),
}

#[derive(Debug)]
enum ShowSubcommand {
    Help,
    Version,
    Variables,
    History(Option<usize>),
}

#[derive(Debug)]
enum ClearTarget {
    Variables,
    History,
}

#[derive(Debug)]
enum HistorySubcommand {
    List(Option<usize>),
    Search(String),
    Clear,
}

// ========== 命令解析器 ==========
fn parse_to_command(tokens: Vec<String>) -> Result<Command> {
    if tokens.is_empty() {
        return Err(TypeCmdError::Parse("空命令".to_string()));
    }
    
    let cmd = tokens[0].to_lowercase();
    let args = &tokens[1..];
    
    match cmd.as_str() {
        "show" => parse_show_command(args),
        "exit" | "quit" | "q" => parse_exit_command(args),
        "to" | "var" | "let" | "set" => parse_set_command(args),
        "get" | "which" | "echo" => parse_get_command(args),
        "string" | "str" | "sprint" => parse_string_command(args),
        "int" | "num" => parse_int_command(args),
        "ls" | "list" => Ok(Command::List),
        "rm" | "del" | "unset" => parse_delete_command(args),
        "clear" | "cls" => parse_clear_command(args),
        "history" | "hist" => parse_history_command(args),
        "!!" => Ok(Command::LastCommand),
        "!" => {
            if args.is_empty() {
                Err(TypeCmdError::InsufficientArgs("历史命令需要参数".to_string()))
            } else {
                Ok(Command::HistoryCommand(args[0].clone()))
            }
        }
        _ => Err(TypeCmdError::CommandNotFound(cmd)),
    }
}

fn parse_show_command(args: &[String]) -> Result<Command> {
    if args.is_empty() {
        return Ok(Command::Show(ShowSubcommand::Help));
    }
    
    match args[0].to_lowercase().as_str() {
        "help" => Ok(Command::Show(ShowSubcommand::Help)),
        "ver" | "version" => Ok(Command::Show(ShowSubcommand::Version)),
        "vars" => Ok(Command::Show(ShowSubcommand::Variables)),
        "history" => {
            if args.len() > 1 {
                if let Ok(limit) = args[1].parse::<usize>() {
                    Ok(Command::Show(ShowSubcommand::History(Some(limit))))
                } else {
                    Err(TypeCmdError::Parse("无效的历史记录限制".to_string()))
                }
            } else {
                Ok(Command::Show(ShowSubcommand::History(None)))
            }
        }
        _ => Err(TypeCmdError::Parse(format!("未知的show子命令: {}", args[0]))),
    }
}

fn parse_exit_command(args: &[String]) -> Result<Command> {
    if args.is_empty() {
        Ok(Command::Exit(None))
    } else {
        match args[0].parse::<i32>() {
            Ok(code) => Ok(Command::Exit(Some(code))),
            Err(_) => Err(TypeCmdError::Parse("无效的退出码".to_string())),
        }
    }
}

fn parse_set_command(args: &[String]) -> Result<Command> {
    if args.len() < 2 {
        return Err(TypeCmdError::InsufficientArgs(
            "set命令需要至少2个参数".to_string(),
        ));
    }
    
    let var_name = args[0].clone();
    let value = args[1..].join(" ");
    Ok(Command::Set(var_name, value))
}

fn parse_get_command(args: &[String]) -> Result<Command> {
    if args.is_empty() {
        return Err(TypeCmdError::InsufficientArgs(
            "get命令需要变量名".to_string(),
        ));
    }
    
    Ok(Command::Get(args[0].clone()))
}

fn parse_string_command(args: &[String]) -> Result<Command> {
    let text = if args.is_empty() {
        String::new()
    } else {
        args.join(" ")
    };
    
    Ok(Command::StringCmd(text))
}

fn parse_int_command(args: &[String]) -> Result<Command> {
    if args.is_empty() {
        Ok(Command::IntCmd(None))
    } else {
        match args[0].parse::<i32>() {
            Ok(num) => Ok(Command::IntCmd(Some(num))),
            Err(_) => Err(TypeCmdError::Parse("无效的数字".to_string())),
        }
    }
}

fn parse_delete_command(args: &[String]) -> Result<Command> {
    if args.is_empty() {
        return Err(TypeCmdError::InsufficientArgs(
            "delete命令需要变量名".to_string(),
        ));
    }
    
    Ok(Command::Delete(args[0].clone()))
}

fn parse_clear_command(args: &[String]) -> Result<Command> {
    if args.is_empty() || args[0].to_lowercase() == "vars" {
        Ok(Command::Clear(ClearTarget::Variables))
    } else if args[0].to_lowercase() == "history" {
        Ok(Command::Clear(ClearTarget::History))
    } else {
        Err(TypeCmdError::Parse("clear命令参数应为: vars 或 history".to_string()))
    }
}

fn parse_history_command(args: &[String]) -> Result<Command> {
    if args.is_empty() {
        Ok(Command::History(HistorySubcommand::List(None)))
    } else {
        match args[0].to_lowercase().as_str() {
            "clear" => Ok(Command::History(HistorySubcommand::Clear)),
            "search" => {
                if args.len() < 2 {
                    Err(TypeCmdError::InsufficientArgs("搜索需要关键词".to_string()))
                } else {
                    Ok(Command::History(HistorySubcommand::Search(args[1].clone())))
                }
            }
            _ => {
                if let Ok(limit) = args[0].parse::<usize>() {
                    Ok(Command::History(HistorySubcommand::List(Some(limit))))
                } else {
                    Err(TypeCmdError::Parse("无效的历史命令参数".to_string()))
                }
            }
        }
    }
}

// ========== 主应用程序 ==========
struct TypeCmd {
    variables: VariableStore,
    history: HistoryManager,
    version: String,
}

impl TypeCmd {
    fn new() -> Result<Self> {
        let history = HistoryManager::new()?;
        
        Ok(TypeCmd {
            variables: VariableStore::new(),
            history,
            version: "0.4.0".to_string(),
        })
    }
    
    fn execute_command(&mut self, input: &str) -> Result<Option<String>> {
        let tokens = parse_command(input)?;
        let command = parse_to_command(tokens)?;
        
        match command {
            Command::Show(subcmd) => self.handle_show(subcmd),
            Command::Exit(code) => self.handle_exit(code),
            Command::Set(var, value) => self.handle_set(&var, &value),
            Command::Get(var) => self.handle_get(&var),
            Command::StringCmd(text) => self.handle_string(&text),
            Command::IntCmd(num) => self.handle_int(num),
            Command::List => self.handle_list(),
            Command::Delete(var) => self.handle_delete(&var),
            Command::Clear(target) => self.handle_clear(target),
            Command::History(subcmd) => self.handle_history(subcmd),
            Command::LastCommand => self.handle_last_command(),
            Command::HistoryCommand(spec) => self.handle_history_command(&spec),
        }
    }
    
    fn handle_show(&self, subcmd: ShowSubcommand) -> Result<Option<String>> {
        match subcmd {
            ShowSubcommand::Help => self.show_help(),
            ShowSubcommand::Version => self.show_version(),
            ShowSubcommand::Variables => self.show_variables(),
            ShowSubcommand::History(limit) => self.show_history(limit),
        }
    }
    
    fn show_help(&self) -> Result<Option<String>> {
        let help_text = format!(
            "{}{}TypeCmd 命令行模拟器{}\n\
            版本: {}\n\
            历史记录: {} 条命令\n\n{}\
            {}基础命令:{}\n{}\
              show                             - 显示信息: show [help|ver|vars|history]\n\
              exit    | quit  | q              - 退出程序\n\
              to      | var   | let   | set    - 设置变量: to <变量名> <值>\n\
              get     | which | echo           - 获取变量: get <变量名>\n\
              copy    | cpvar                  - 复制变量: copy <新变量名> <旧变量名>
              string  | str                    - 字符串输出: string <文本>\n\
              int     | num                    - 数字处理: int <数字>\n\
              list    | ls                     - 列出所有变量\n\
              rm      | del   | unset          - 删除变量: rm <变量名>\n\
              clear   | cls                    - 清空所有变量或历史\n\
              history | hist                   - 显示历史命令\n\n\
            {}历史命令使用:{}\n{}\
              !!                               - 执行上一条命令\n\
              ! n                              - 执行历史第n条命令\n\
              ! -n                             - 执行历史倒数第n条命令\n\
              history | hist                   - 显示所有历史命令\n\
              history | hist n                 - 显示最近n条历史命令\n\
              history | hist search str        - 搜索包含str的历史命令\n\
              history | hist clear             - 清除所有历史记录\n\
            {}",
            /*
                "show" => parse_show_command(args),
                "exit" | "quit" | "q" => parse_exit_command(args),
                "to" | "var" | "let" | "set" => parse_set_command(args),
                "get" | "which" | "echo" => parse_get_command(args),
                "string" | "str" | "sprint" => parse_string_command(args),
                "int" | "num" => parse_int_command(args),
                "ls" | "list" => Ok(Command::List),
                "rm" | "del" | "unset" => parse_delete_command(args),
                "clear" | "cls" => parse_clear_command(args),
                "history" | "hist" => parse_history_command(args),
             */
            BOLD, BLUE, RESET,
            self.version,
            self.history.count(), BLUE, 
            BOLD, RESET, BLUE, 
            BOLD, RESET, BLUE, RESET, 
        );
        
        print_info(&help_text);
        Ok(Some(help_text))
    }
    
    fn show_version(&self) -> Result<Option<String>> {
        let msg = format!("TypeCmd Version {}", self.version);
        print_info(&msg);
        Ok(Some(msg))
    }
    
    fn show_variables(&self) -> Result<Option<String>> {
        let vars = self.variables.all();
        
        if vars.is_empty() {
            let msg = "没有定义的变量";
            print_info(msg);
            return Ok(Some(msg.to_string()));
        }
        
        let mut output = format!("已定义的变量 (共{}个):\n", vars.len());
        for (key, value) in vars {
            output.push_str(&format!("  {:15} = \"{}\"\n", key, value));
        }
        
        print_info(&output);
        Ok(Some(output))
    }
    
    fn show_history(&self, limit: Option<usize>) -> Result<Option<String>> {
        let entries: Vec<HistoryEntry> = if let Some(l) = limit {
            self.history.get(Some(l))
        } else {
            self.history.get(None)
        };
        
        if entries.is_empty() {
            let msg = "历史记录为空";
            print_info(msg);
            return Ok(Some(msg.to_string()));
        }
        
        let limit_str = if let Some(l) = limit {
            format!("最近{}条", l)
        } else {
            "所有".to_string()
        };
        
        let mut output = format!("历史命令 ({}):\n", limit_str);
        for entry in entries.iter().rev() {
            let time_str = entry.timestamp.format("%H:%M:%S").to_string();
            output.push_str(&format!(
                "{:4}  [{}]  {}\n",
                entry.id, time_str, entry.command
            ));
        }
        
        output.push_str("\n使用 !<编号> 执行历史命令");
        
        print_info(&output);
        Ok(Some(output))
    }
    
    fn handle_exit(&self, code: Option<i32>) -> Result<Option<String>> {
        let exit_code = code.unwrap_or(0);
        print_success(&format!("再见! (退出码: {})", exit_code));
        exit(exit_code);
    }
    
    fn handle_set(&mut self, var: &str, value: &str) -> Result<Option<String>> {
        self.variables.set(var.to_string(), value.to_string());
        let msg = format!("变量 \"{}\" 已设置为 \"{}\"", var, value);
        print_success(&msg);
        Ok(Some(msg))
    }
    
    fn handle_get(&self, var: &str) -> Result<Option<String>> {
        match self.variables.get(var) {
            Some(value) => {
                let msg = format!("变量 {} 的值为: {}", var, value);
                print_info(&msg);
                Ok(Some(value.clone()))
            }
            None => {
                let err = format!("未定义的变量: {}", var);
                print_error(&err);
                Err(TypeCmdError::UndefinedVariable(var.to_string()))
            }
        }
    }
    
    fn handle_string(&self, text: &str) -> Result<Option<String>> {
        print_info(text);
        Ok(Some(text.to_string()))
    }
    
    fn handle_int(&self, num: Option<i32>) -> Result<Option<String>> {
        let num_str = num.unwrap_or(0).to_string();
        print_info(&num_str);
        Ok(Some(num_str))
    }
    
    fn handle_list(&self) -> Result<Option<String>> {
        self.show_variables()
    }
    
    fn handle_delete(&mut self, var: &str) -> Result<Option<String>> {
        if self.variables.delete(var) {
            let msg = format!("已删除变量: {}", var);
            print_success(&msg);
            Ok(Some(msg))
        } else {
            let err = format!("变量不存在: {}", var);
            print_error(&err);
            Err(TypeCmdError::UndefinedVariable(var.to_string()))
        }
    }
    
    fn handle_clear(&mut self, target: ClearTarget) -> Result<Option<String>> {
        match target {
            ClearTarget::Variables => {
                let count = self.variables.len();
                self.variables.clear();
                let msg = format!("已清除所有变量 (共{}个)", count);
                print_success(&msg);
                Ok(Some(msg))
            }
            ClearTarget::History => {
                self.history.clear()?;
                let msg = "已清除所有历史记录".to_string();
                print_success(&msg);
                Ok(Some(msg))
            }
        }
    }
    
    fn handle_history(&mut self, subcmd: HistorySubcommand) -> Result<Option<String>> {
        match subcmd {
            HistorySubcommand::List(limit) => self.show_history(limit),
            HistorySubcommand::Search(keyword) => self.search_history(&keyword),
            HistorySubcommand::Clear => {
                self.history.clear()?;
                let msg = "历史记录已清除".to_string();
                print_success(&msg);
                Ok(Some(msg))
            }
        }
    }
    
    fn search_history(&self, keyword: &str) -> Result<Option<String>> {
        let results = self.history.search(keyword);
        
        if results.is_empty() {
            let msg = format!("没有找到包含 \"{}\" 的历史命令", keyword);
            print_info(&msg);
            return Ok(Some(msg));
        }
        
        let mut output = format!("搜索 \"{}\" 的结果 ({}条):\n", keyword, results.len());
        for entry in results.iter().take(20) {
            let time_str = entry.timestamp.format("%H:%M:%S").to_string();
            output.push_str(&format!(
                "{:4}  [{}]  {}\n",
                entry.id, time_str, entry.command
            ));
        }
        
        print_info(&output);
        Ok(Some(output))
    }
    
    fn handle_last_command(&mut self) -> Result<Option<String>> {
        // 修复借用问题：先获取命令字符串，然后释放借用
        let command_to_execute = match self.history.last() {
            Some(entry) => {
                print_gray(&format!("执行历史命令 #{}: {}", entry.id, entry.command));
                entry.command.clone()
            }
            None => {
                let err = "没有历史命令可执行";
                print_error(err);
                return Err(TypeCmdError::InvalidHistoryCommand(err.to_string()));
            }
        };
        
        // 现在执行命令，此时对history的借用已经结束
        self.execute_command(&command_to_execute)
    }
    
    fn handle_history_command(&mut self, spec: &str) -> Result<Option<String>> {
        // 修复借用问题：先获取命令字符串，然后释放借用
        let command_to_execute = if spec.starts_with('-') {
            // 格式: !-n
            let offset_str = &spec[1..];
            let offset: usize = offset_str.parse()
                .map_err(|_| TypeCmdError::InvalidHistoryCommand(
                    format!("无效的偏移量: {}", spec)
                ))?;
            
            let entries = self.history.get(None);
            if offset == 0 || offset > entries.len() {
                return Err(TypeCmdError::InvalidHistoryCommand(
                    format!("偏移量超出范围 (共{}条)", entries.len())
                ));
            }
            
            let entry = &entries[entries.len() - offset];
            print_gray(&format!("执行历史命令 #{}: {}", entry.id, entry.command));
            entry.command.clone()
        } else {
            // 格式: !n
            let id: u64 = spec.parse()
                .map_err(|_| TypeCmdError::InvalidHistoryCommand(
                    format!("无效的历史命令ID: {}", spec)
                ))?;
            
            match self.history.get_by_id(id) {
                Some(entry) => {
                    print_gray(&format!("执行历史命令 #{}: {}", entry.id, entry.command));
                    entry.command.clone()
                }
                None => {
                    let err = format!("历史命令 #{} 不存在", id);
                    print_error(&err);
                    return Err(TypeCmdError::InvalidHistoryCommand(err));
                }
            }
        };
        
        // 现在执行命令，此时对history的借用已经结束
        self.execute_command(&command_to_execute)
    }
    
    fn show_prompt(&self) {
        let var_count = self.variables.len();
        let hist_count = self.history.count();
        
        let mut prompt = format!("{}TypeCmd{}{}@{}{}{}{}", PURPLE, RESET, CYAN, RESET, BLUE, self.version, RESET);
        
        if var_count > 0 {
            prompt.push_str(&format!(" {}[{} vars]{}", CYAN, var_count, RESET));
        }
        
        if hist_count > 0 {
            prompt.push_str(&format!(" {}[{} hist]{}", GREEN, hist_count, RESET));
        }
        
        prompt.push_str(&format!("\n{}${} ", PURPLE, RESET));
        print!("{}", prompt);
        io::stdout().flush().unwrap();
    }
    
    fn run(&mut self) -> Result<()> {
        print_info(&format!("TypeCmd {} - 输入 'show help' 查看帮助", self.version));
        
        loop {
            self.show_prompt();
            
            let mut input = String::new();
            io::stdin().read_line(&mut input)?;
            let input = input.trim();
            
            if input.is_empty() {
                continue;
            }
            
            // 添加到历史记录
            if let Err(e) = self.history.add(input) {
                print_warn(&format!("无法保存历史记录: {}", e));
            }
            
            // 处理特殊历史命令语法
            let result = if input == "!!" {
                self.execute_command(input)
            } else if input.starts_with('!') && input.len() > 1 {
                // 解析!命令
                let tokens = parse_command(input)?;
                if !tokens.is_empty() && tokens[0] == "!" && tokens.len() > 1 {
                    self.execute_command(input)
                } else {
                    self.execute_command(input)
                }
            } else {
                self.execute_command(input)
            };
            
            match result {
                Ok(_) => {}
                Err(e) => {
                    print_error(&format!("{}", e));
                }
            }
        }
    }
}

// ========== 主函数 ==========
fn main() -> Result<()> {
    let mut app = TypeCmd::new()?;
    app.run()
}